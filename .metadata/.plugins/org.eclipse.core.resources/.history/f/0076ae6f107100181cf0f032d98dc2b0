package co.megadodo.terraingen1.light;

import java.util.ArrayList;

import com.jme3.math.Vector2f;
import com.jme3.math.Vector3f;

import co.megadodo.mcclone1.appstate.AppStateWorld;
import co.megadodo.terraingen1.block.Chunk;
import co.megadodo.terraingen1.config.JME3TerrainGenerationConfig;

//Home of the lighting algorithms
//Bend your head down in submission
//To the all-powerful...
//FLOOD-FILL lighting algorithm!!!
//No seriously this is pretty cool stuff.
public class LightingManager {

	//A light source
	static class LightSource {
		Vector3f pos;
		float col;
		
		LightSource(Vector3f pos, float col) {
			this.pos=pos;
			this.col=col;
		}
	}
	//A lit position
	static class LightPos {
		Vector3f pos;
		float col;
		
		LightPos(Vector3f pos, float col) {
			this.pos=pos;
			this.col=col;
		}
	}
	
	//lights, lit positions
	static ArrayList<LightSource> lights;
	static ArrayList<LightPos> posses;
	static {
		lights=new ArrayList<LightSource>();
		posses = new ArrayList<LightPos>();
//		updateLights();
	}
	public static void addLight(Vector3f pos) {
		LightSource ls = new LightSource(pos,16);
		lights.add(ls);
	}
	//Add a light strength to a position without propogation
	//USed only by lightingManager
	public static void addCol(float col,Vector3f pos) {
		for(LightPos p : posses) {
			if(p.pos.equals(pos)) {
				p.col+=col;
				return;
			}
		}
		posses.add(new LightPos(pos,col));
	}
	//TODO: change with time of day
	//TODO: make sunlight float-based, not int-based for gradual transitions
	static float sunlightLevel=10;
	//^ sunlight level
	//v calculates sunlight, which is distance from nearest above block
	public static float sunlight(int cx,int cz,int x,int y,int z,AppStateWorld asw) {
		Chunk c=asw.findChunk(cx, cz).data;
		if(y==-1)return 0;
//		if(Math.abs(y-c.highestY(x, z))<=1)return 10;
		float result=c.sunLightCalc(x,y,z);
		float light=(int)(Math.abs(y-result));
		if(light<0)return 0;
		if(light>15)return sunlightLevel;
		return light;
//		return 5;
		//TODO: above should be 16-3*(distance from nearest sunlight), but 5 works well to give the illusion of shadow
		//TODO; sugguestion 1 has merit, things get high light that are not visible to sunlight
		//TODO: or maybe : 16-3*(distance from above block) to simulate shadows near, but 
	}
	//Does flood-fill light propogation
	public static ArrayList<Vector2f> updateLights(AppStateWorld asw) {
//		System.out.println("Start update lights");
		posses = new ArrayList<LightPos>();
		ArrayList<Vector2f> cUpdates = new ArrayList<Vector2f>();
//		int numIters = 0;
		for(LightSource source : lights) {
//			System.out.println("Light");
			ArrayList<Vector3f> open = new ArrayList<Vector3f>();
			ArrayList<Float> lightVals = new ArrayList<Float>();
			ArrayList<Vector3f> closed = new ArrayList<Vector3f>();
			open.add(source.pos);
			lightVals.add(16f);
			while(open.size()>0) {
//				System.out.println("Light iter");
				Vector3f pos = open.get(0);
				open.remove(0);
				int cx=(int)(pos.x/16);
				int cz=(int)(pos.z/16);
				int rx=(int)(pos.x%16);
				int ry=(int)(pos.y);
				int rz=(int)(pos.z%16);
				while(rx<0) {
					rx+=16;
					cx--;
				}
				while(rz<0) {
					rz+=16;
					cz--;
				}
				while(rx>15) {
					rx-=16;
					cx++;
				}
				while(rz>15) {
					rz-=15;
					cz++;
				}
				float c = lightVals.get(0);
				lightVals.remove(0);
				if(c<=0)continue;
				if(closed.contains(pos)) {
					continue;
				}
				closed.add(pos);
				if(asw.findChunk(cx, cz).data.data[rx][ry][rz]==null) {
					addCol(c, pos);
					Vector2f cpos = new Vector2f(cx,cz);
					if(!cUpdates.contains(cpos))cUpdates.add(cpos);
					open.add(new Vector3f(pos.x-1,pos.y,pos.z));
					open.add(new Vector3f(pos.x+1,pos.y,pos.z));
					open.add(new Vector3f(pos.x,pos.y-1,pos.z));
					open.add(new Vector3f(pos.x,pos.y+1,pos.z));
					open.add(new Vector3f(pos.x,pos.y,pos.z-1));
					open.add(new Vector3f(pos.x,pos.y,pos.z+1));
					for(int i=0;i<6;i++) {
						lightVals.add(c-2f);  //2/16 light is lost every block
					}
				}
			}
		}
//		System.out.println("Light update:");
//		System.out.println("Iterations: " +numIters);
//		System.out.println("Num light posses: " + posses.size());
		return cUpdates;
	}
	
	//Adds up all light values
	public static float colorForPos(Vector3f pos,AppStateWorld asw) {
//		float col=5f;
//		for(LightPos p : posses) {
//			if(p.pos.equals(pos)) {
////				System.out.println("Non-default at " + p.pos + ": " + p.col);
//				col+=p.col;
//			}
//		}
//		int cx=0;
//		int cz=0;
//		int x=(int)pos.x;
//		int y=(int)pos.y;
//		int z=(int)pos.z;
//		while(x>15) {
//			cx++;
//			x-=16;
//		}
//		while(z>15) {
//			cz++;
//			z-=16;
//		}
//		while(x<0) {
//			cx--;
//			x+=16;
//		}
//		while(z<0) {
//			cz--;
//			z+=16;
//		}
//		col+=sunlight(cx, cz, x, y, z, asw);
//		if(col>16)col=16;
//		if(col<0)col=0;
//		return col/16f;
		float ambient=0;
		float actual=0;
		float sun=0;
		//What type of ambient light?
		switch(JME3TerrainGenerationConfig.ambientMethod) {
		case BRIGHT:
			ambient=12;
			break;
		case DARK:
			ambient=2;
			break;
		case MODERATE:
			ambient=8;
			break;
		}
		//What type of actual light?
		switch(JME3TerrainGenerationConfig.lightingMethod) {
		case NONE:
			actual=0;
			break;
		case REALISTIC:
			for(LightPos p : posses) {
				if(p.pos.equals(pos)) {
//					System.out.println("Non-default at " + p.pos + ": " + p.col);
					actual+=p.col;
				}
			}
			break;
		}
		//What type of sunlight?
		switch(JME3TerrainGenerationConfig.sunlightMethod) {
		case MODERATE:
			int cx=0;
			int cz=0;
			int x=(int)pos.x;
			int y=(int)pos.y;
			int z=(int)pos.z;
			while(x>15) {
				cx++;
				x-=16;
			}
			while(z>15) {
				cz++;
				z-=16;
			}
			while(x<0) {
				cx--;
				x+=16;
			}
			while(z<0) {
				cz--;
				z+=16;
			}
			sun=sunlight(cx, cz, x, y, z, asw)*2f-3f;
			break;
		case NONE:
			sun=0;
			break;
		}
		float val=ambient+actual+sun;
		if(val<0)val=0;
		if(val>16)val=16;
		return val/16f;
	}
	
}
