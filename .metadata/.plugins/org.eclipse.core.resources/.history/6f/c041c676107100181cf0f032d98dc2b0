package co.megadodo.terraingen1.gen.mine2;

import java.util.ArrayList;

import co.megadodo.mcclone.Utils;
import co.megadodo.mcclone.block.BlockState;
import co.megadodo.mcclone.block.Chunk;
import co.megadodo.mcclone.gen.AbstractChunkProvider;
import co.megadodo.mcclone.gen.mine1.Blocks;
import co.megadodo.mcclone.gen.noise.ModuleRidge;
import co.megadodo.mcclone.gen.noise.NoiseModule;

//This is currently used
//And coming along great.
public class ChunkProviderMine2 extends AbstractChunkProvider {

	@Override
	public void initialize() {
		// TODO Auto-generated method stub

	}

	@Override
	public void onChunkRemoveBefore(int cx, int cz) {
		// TODO Auto-generated method stub

	}

	@Override
	public void onChunkRemoveAfter(int cx, int cz) {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean canChunkRemove(int cx, int cz) {
		// TODO Auto-generated method stub
		return true;
	}

	@Override
	public void onChunkAddBefore(int cx, int cz) {
		// TODO Auto-generated method stub

	}

	@Override
	public void onChunkAddAfter(int cx, int cz) {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean canChunkAdd(int cx, int cz) {
		// TODO Auto-generated method stub
		return true;
	}

	static NoiseModule ridge;
	static {
		ridge = new ModuleRidge();
	}

	static BlockState getRandBlock() {
		// int randNum=(int)(Math.random()*3);
		// if(randNum==0)return Blocks.DIRT.getDefaultState();
		// if(randNum==1)return Blocks.STONE.getDefaultState();
		// if(randNum==2)return Blocks.SAND.getDefaultState();
		// return null;
		return Blocks.GRASS.getState("Forest");
	}

	float elevScale = 1.5f;
	float roughScale = 2f;
	float detailScale = 2f;
	float smoothScale = 0f;
	float hillMargin = 0.8f;
	float hillProtrusion = 75f;
	float rScale = 1f;
	float valleyMargin=0.2f;
	float valleyDepth=30;

	float calcHills(int x, int z) {
		return Utils.noisePerlin2(x * roughScale + 100, z * roughScale + 100) * rScale;
	}
	
	float flip(float x, float around) {
		x-=around/2;
		x=Utils.abs(around);
		x+=around/2;
		return x;
	}

	//Gets  heightmap at x,z
	//Currently testing hills
	float height(int x, int z) {
		float elev = Utils.noisePerlin2(x * elevScale, z * elevScale);
		float rough = calcHills(x, z);
//		float hill1=0.8f;
//		float hill2=0.5f-hill1/2f;
//		if(rough>hill1) {
//			rough-=hill1;//0,0.1
//			float hillHeight=10;
//			if(rough>hill2) {
//				elev+=hill2*hillHeight;
//				isHill=false;
//			}else {
//				elev+=rough*hillHeight;
//				isHill=true;
//			}
//		}
		isHill=false;
		float hillOffset=0;
		if(rough<0.35f) {
			float hh=10;
			if(rough<0.3f) {
				hillOffset=hh;
				isHill=false;
			}else {
				hillOffset=Utils.map(rough, 0.35f, 0.3f, 0, hh);
				isHill=true;
			}
		}
		// float detail = Utils.noisePerlin2(x * detailScale + 200, z * detailScale +
		// 200) * 3;
		// float smooth=Utils.noisePerlin2(x*smoothScale+300, z*smoothScale+300);
		// return (elev+(rough*detail))*10+64;
		return 30 * elev + 64+hillOffset;
	}

	boolean isHill = false;

	@Override
	public Chunk makeChunk(int cx, int cz, ArrayList<BlockState> bls) {
		Chunk chunk = new Chunk();
		for (int x = 0; x < 16; x++) {
			for (int z = 0; z < 16; z++) {
				// float noiseF=ridge.getValue( (cx*16+x)*zoom, 0, (cz*16+z)*zoom)*scale+offset;
				float noiseF = height(x + cx * 16, z + cz * 16);
				int noiseI = (int) noiseF;
				// chunk.data[x][noiseI][z]=Blocks.STONE.getDefaultState();
				BlockState top = Blocks.GRASS.getState("Forest");
				BlockState mid = Blocks.DIRT.getDefaultState();
				if (isHill)
					top = Blocks.GRASS.getState("Savanna");
				// if(noiseI<=160) {
				// noiseI=160;
				// top=Blocks.WATER.getDefaultState();
				// }
				if(noiseI>255)noiseI=255;
				for (int y = 0; y <= noiseI; y++) {
					// float noise3 = Utils.noisePerlin3(x + cx * 16, y, z + cz * 16);
					// if (noise3 < 0.4 || noise3 > 0.6) {
					if (y == noiseI)
						chunk.data[x][y][z] = top;
					else if (y >= noiseI - 10)
						chunk.data[x][y][z] = mid;
					else
						chunk.data[x][y][z] = Blocks.STONE.getDefaultState();
					// }
				}
			}
		}
		return chunk;
	}

}
