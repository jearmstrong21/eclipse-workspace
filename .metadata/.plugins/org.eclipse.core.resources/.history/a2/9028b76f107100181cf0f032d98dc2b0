package co.megadodo.mcclone1;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;

import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import com.jme3.math.Vector2f;
import com.jme3.math.Vector3f;

import co.megadodo.terraingen1.block.BlockState;
import co.megadodo.terraingen1.gen.FastNoise;

//Utility class
public class Utils {

	//Create empty column
	public static BlockState[] emptyColumn() {
		BlockState[] b = new BlockState[256];
		for (int i = 0; i < 256; i++) {
			b[i] = null;
		}
		return b;
	}

	//For timing, analytical purposes
	//I don't think this is used, but I keep it
	//for later
	private static long startTime = -1;
	private static long endTime = -1;
	private static boolean timing = false;

	public static void startTiming() {
		if(timing) {
			System.out.println("Could not start timing.");
			return;
		}
		timing = true;
		startTime = System.currentTimeMillis();
	}

	public static long endTime() {
		if(!timing) {
			System.out.println("Not currently timing.");
			return -1;
		}
		timing = false;
		endTime = System.currentTimeMillis();
		return endTime - startTime;
	}

	//Absolute value
	public static float abs(float a) {
		return Math.abs(a);
	}

	//Random float in range [0,1]
	public static float randFloat() {
		return (float) Math.random();
	}

	//Random float in range [0,a]
	public static float randFloat(float a) {
		return a * randFloat();
	}

	//Random float in range [a,b]
	public static float randFloat(float a, float b) {
		return randFloat(b - a) + a;
	}

	// Linear interpolation
	public static float lerp(float t, float a, float b) {
		return (b - a) * t + a;
	}

	// Normalize in range
	public static float norm(float t, float a, float b) {
		return (t - a) / (b - a);
	}

	// Map from one range to another
	public static float map(float val, float s1, float e1, float s2, float e2) {
		return lerp(norm(val, s1, e1), s2, e2);
	}

	//Bilinear interpolation
	public static float blerp(float a00, float a10, float a01, float a11, float x, float y) {
		return a00 * (1 - x) * (1 - y) + a10 * x * (1 - y) + a01 * (1 - x) * y + a11 * x * y;
	}

	// FastNoise instance for noise computations
	private static FastNoise fastNoise;

	//Static initialization with random seed
	//TODO: move seed to JME3TerrainGenerationConfig
	static {
		fastNoise = new FastNoise();
		fastNoise.SetSeed((int) (Math.random() * Integer.MAX_VALUE));
	}

	//Perlin noise 2d
	public static float noisePerlin2(float x, float y) {
		return map(fastNoise.GetPerlin(x, y),-1,1,0,1);
//		return (int)SimplexNoise.noise(x, y);
	}

	//Perlin noise 3d
	public static float noisePerlin3(float x, float y, float z) {
		return map(fastNoise.GetPerlin(x, y, z),-1,1,0,1);
//		return (int)SimplexNoise.noise(x, y, z);
	}

	//Test noise distributions
	public static void main(String[] args) {
		float mi3 = 1000, ma3 = 0,mi2=1000,ma2=0,r=700;
		for (int x = 0; x < r; x++) {
			for (int y = 0; y < r; y++) {
				float n=noisePerlin2(x,y);
				if(ma2<n)ma2=n;
				if(mi2>n)mi2=n;
				for (int z = 0; z < r; z++) {
					n=noisePerlin3(x,y,z);
					if(ma3<n)ma3=n;
					if(mi3>n)mi3=n;
				}
			}
		}
		System.out.println("Min2:" + mi2);
		System.out.println("Max2:" + ma2);
		System.out.println("Min3:" + mi3);
		System.out.println("Max3:" + ma3);
	}

	//Load JSONObject from file
	public static JSONObject loadObject(String filename) {
		try {
			return new JSONObject(new JSONTokener(new FileInputStream(new File("JSON/" + filename))));
		} catch (JSONException e) {
			e.printStackTrace();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		return null;
	}

	//ArrayList<Integer> to int[] conversion
	public static int[] listToArrayInt(ArrayList<Integer> ints) {
		int[] nums = new int[ints.size()];
		for (int x = 0; x < ints.size(); x++) {
			nums[x] = ints.get(x);
		}
		return nums;
	}

	//ArrayList<Vector3f> to float[] conversion - every three floats in array corresponds to x,y,z coordinates
	public static float[] vec3ToFloats(ArrayList<Vector3f> vecs) {
		float[] vs = new float[vecs.size() * 3];
		for (int i = 0; i < vecs.size(); i++) {
			vs[i * 3 + 0] = vecs.get(i).x;
			vs[i * 3 + 1] = vecs.get(i).y;
			vs[i * 3 + 2] = vecs.get(i).z;
		}
		return vs;
	}

	//ArrayList<Vector2f> to float[] conversion - every three floats in array corresponds to x,y coordinates
	public static float[] vec2ToFloats(ArrayList<Vector2f> vecs) {
		float[] vs = new float[vecs.size() * 2];
		for (int i = 0; i < vecs.size(); i++) {
			vs[i * 2 + 0] = vecs.get(i).x;
			vs[i * 2 + 1] = vecs.get(i).y;
		}
		return vs;
	}

	//Add one vector to each individual item in the list
	public static ArrayList<Vector3f> addVecToList(ArrayList<Vector3f> vecs, Vector3f v) {
		ArrayList<Vector3f> vs = new ArrayList<Vector3f>();
		for (Vector3f item : vecs) {
			vs.add(item.add(v));
		}
		return vs;
	}

	//Add one integer to each individual item in the list
	public static ArrayList<Integer> addNumToList(ArrayList<Integer> ints, int i) {
		ArrayList<Integer> vals = new ArrayList<Integer>();
		for (int x : ints) {
			vals.add(x + i);
		}
		return vals;
	}

	//XOR operation
	public static boolean xor(boolean a, boolean b) {
		return a != b;
	}

}
