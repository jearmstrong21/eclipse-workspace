package co.megadodo.mcclone.appstate;

import java.util.ArrayList;

import com.jme3.app.Application;
import com.jme3.app.state.AbstractAppState;
import com.jme3.app.state.AppStateManager;
import com.jme3.bounding.BoundingSphere;
import com.jme3.input.KeyInput;
import com.jme3.input.MouseInput;
import com.jme3.input.controls.ActionListener;
import com.jme3.input.controls.KeyTrigger;
import com.jme3.input.controls.MouseButtonTrigger;
import com.jme3.material.Material;
import com.jme3.math.ColorRGBA;
import com.jme3.math.Vector2f;
import com.jme3.math.Vector3f;
import com.jme3.post.FilterPostProcessor;
import com.jme3.post.filters.BloomFilter;
import com.jme3.post.filters.DepthOfFieldFilter;
import com.jme3.post.filters.FXAAFilter;
import com.jme3.post.filters.LightScatteringFilter;
import com.jme3.renderer.queue.RenderQueue.Bucket;
import com.jme3.scene.Geometry;
import com.jme3.scene.Node;
import com.jme3.texture.Texture;
import com.jme3.water.WaterFilter;

import co.megadodo.mcclone.TerrainGeneration;
import co.megadodo.mcclone.Utils;
import co.megadodo.mcclone.block.Chunk;
import co.megadodo.mcclone.block.MatType;
import co.megadodo.mcclone.config.JME3TerrainGenerationConfig;
import co.megadodo.mcclone.gen.AbstractChunkProvider;
import co.megadodo.mcclone.gen.mine1.Blocks;
import co.megadodo.mcclone.light.LightingManager;
import co.megadodo.mcclone.mesh.MeshData;

//Takes care of instantiation and removal of chunks
//Breaking/placing of blocks
public class AppStateWorld extends AbstractAppState {
	
	//Shortcut for rounding
	static int roundPos(float a) {
		return Math.round(a);
	}
	
	//Do a raytrace from a position in a direction
	//TODO: will go out of bounds
	public RayTraceResult rayTrace(Vector3f pos, Vector3f dir) {
		//Vectors are cloned to prevent accidental modification of referenced vectors
		Vector3f cur = pos.clone();
		RayTraceResult rtr = new RayTraceResult();
		Vector3f inc = dir.clone().mult(0.5f);
		
		//lx,ly,lz are last position in chunk
		//lcx,lcz are last chunk
		//x,y,z are position in chunk
		//cx,cz are chunk
		//num is current number of iterations, after 50 iterations (about 25 blocks) it ends
		boolean keepGoing = true;
		int lx=0;
		int ly=0;
		int lz=0;
		int lcx=0;
		int lcz=0;
		int x=0;
		int y=0;
		int z=0;
		int cx=0;
		int cz=0;
		int num=0;
		while(keepGoing) {
			num++;
			if(num>50)keepGoing=false;
			cur=cur.add(inc);
			lx=x;
			ly=y;
			lz=z;
			lcx=cx;
			lcz=cz;
			//Get cx,cz,x,y,z
			cx=roundPos(cur.x)/16;
			cz=roundPos(cur.z)/16;
			x=roundPos(cur.x)%16;
			y=roundPos(cur.y);
			z=roundPos(cur.z)%16;
			//While x,z are out of bounds, move closer inbounds
			while(x<0) {
				x+=16;
				cx--;
			}
			while(z<0) {
				z+=16;
				cz--;
			}
			while(x>15) {
				x-=16;
				cx++;
			}
			while(z>15) {
				z-=16;
				cz++;
			}
			//TODO: This is supposed to prevent index out of bounds exceptions, but it doesnt for some reason :(
			if(y>255||y<0)keepGoing=false;
			else {
				//find the chunk, if a hit then return that hit
				ChunkPair p = findChunk(cx,cz);
				if(p==null) {
					keepGoing=false;
				}else {
					if(p.data.data[x][y][z]!=null) {
						keepGoing=false;
					}
				}
			}
		}
		//Assign values
		rtr.hitX=x;
		rtr.hitY=y;
		rtr.hitZ=z;
		rtr.hitCX=cx;
		rtr.hitCZ=cz;
		rtr.lX=lx;
		rtr.lY=ly;
		rtr.lZ=lz;
		rtr.lCX=lcx;
		rtr.lCZ=lcz;
		return rtr;
	}
	
	//Main class instance
	public TerrainGeneration tg;
	
	//Number of chunks for use by AppStateGUI
	public static int numChunks = 0;
	
	//Chunk pair
	//cx,cz: chunk coords
	//data: the chunk data
	//inst: is instantiated or not
	public static class ChunkPair{
		int x;
		int z;
		public Chunk data;
		boolean inst = false;
		
		ChunkPair(int x,int z,Chunk c,boolean i) {
			this.x=x;
			this.z=z;
			this.data=c;
			this.inst=i;
		}
		
		//equals method (generated by Eclipse) for arraylists
		//not sure if it helps
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			ChunkPair other = (ChunkPair) obj;
			if (x != other.x)
				return false;
			if (z != other.z)
				return false;
			return true;
		}
	}
	
	//chunkInstNodes[i] corresponds to chunkInstPosses[i]
	
	//Chunk nodes
	ArrayList<Node> chunkInstNodes;
	
	//Chunk positions
	ArrayList<Vector2f> chunkInstPosses;
	
	//Chunk datas
	ArrayList<ChunkPair> chunks;
	
	//find chunks[i] so that chunks[i].x==x&&chunks[i].z==z
	public ChunkPair findChunk(int x, int z) {
		for(ChunkPair p : chunks) {
			if(p.x==x&&p.z==z)return p;
		}
		return new ChunkPair(0,0,null,false);
	}
	
	//World generator
	public AbstractChunkProvider chunkProvider;
	
	@Override
	public void initialize(AppStateManager appstatemanager, Application app) {
		self=this;
		//^ Self is assigned for use in action listeners
		chunkInstNodes = new ArrayList<Node>();
		chunkInstPosses = new ArrayList<Vector2f>();
		chunks = new ArrayList<ChunkPair>();
		//^ Init arraylists
//		chunkProvider = new ChunkProviderFiles();
//		chunkProvider = new ChunkProviderMine1();
//		chunkProvider = new ChunkProviderMine2();
		try {
			//Deprecated, but useful :)
			chunkProvider=JME3TerrainGenerationConfig.chunkProvider.newInstance();
		} catch (Throwable t) {
			//Never will happen
			t.printStackTrace();
			System.out.println("Cannot load chunk provider.");
			System.exit(1);
		}
		//Initialize cp
		chunkProvider.initialize();
		
		//TODO: figure out if these are nesecarry - all water/sunlight shaders
		Vector3f lightDir=new Vector3f(-4.9236743f, -1.27054665f, 5.896916f);
		WaterFilter water = new WaterFilter(tg.getRootNode(), lightDir);
		water.setWaterColor(new ColorRGBA().setAsSrgb(0.0078f, 0.3176f, 0.5f, 1.0f));
        water.setDeepWaterColor(new ColorRGBA().setAsSrgb(0.0039f, 0.00196f, 0.145f, 1.0f));
        water.setUnderWaterFogDistance(80);
        water.setWaterTransparency(0.12f);
        water.setFoamIntensity(0.4f);        
        water.setFoamHardness(0.3f);
        water.setFoamExistence(new Vector3f(0.8f, 8f, 1f));
        water.setReflectionDisplace(50);
        water.setRefractionConstant(0.25f);
        water.setColorExtinction(new Vector3f(30, 50, 70));
        water.setCausticsIntensity(0.4f);        
        water.setWaveScale(0.003f);
        water.setMaxAmplitude(2f);
//        water.setFoamTexture((Texture2D) assetManager.loadTexture("Common/MatDefs/Water/Textures/foam2.jpg"));
        water.setRefractionStrength(0.2f);
        water.setWaterHeight(20);
        BloomFilter bloom = new BloomFilter();        
        bloom.setExposurePower(100);
        bloom.setBloomIntensity(1.0f);
        
        //Light Scattering Filter
        LightScatteringFilter lsf = new LightScatteringFilter(lightDir.mult(-300));
        lsf.setLightDensity(0.5f);   
        
        //Depth of field Filter
        DepthOfFieldFilter dof = new DepthOfFieldFilter();
        dof.setFocusDistance(0);
        dof.setFocusRange(100);
        
        FilterPostProcessor fpp = new FilterPostProcessor(tg.getAssetManager());
        
        fpp.addFilter(water);
        fpp.addFilter(bloom);
        fpp.addFilter(dof);
        fpp.addFilter(lsf);
        fpp.addFilter(new FXAAFilter());
        //LOL don't add any filters or post processors
//        tg.getViewPort().addProcessor(fpp);
		
        //add input mappings
        //Bl0-Bl9 should not be used
		tg.getInputManager().addMapping("Break", new MouseButtonTrigger(MouseInput.BUTTON_LEFT));
		tg.getInputManager().addMapping("Place", new KeyTrigger(KeyInput.KEY_R));
		tg.getInputManager().addMapping("Explosion", new KeyTrigger(KeyInput.KEY_P));
		tg.getInputManager().addMapping("Light", new KeyTrigger(KeyInput.KEY_L));
		tg.getInputManager().addMapping("Bl0", new KeyTrigger(KeyInput.KEY_1));
		tg.getInputManager().addMapping("Bl1", new KeyTrigger(KeyInput.KEY_2));
		tg.getInputManager().addMapping("Bl2", new KeyTrigger(KeyInput.KEY_3));
		tg.getInputManager().addMapping("Bl3", new KeyTrigger(KeyInput.KEY_4));
		tg.getInputManager().addMapping("Bl4", new KeyTrigger(KeyInput.KEY_5));
		tg.getInputManager().addMapping("Bl5", new KeyTrigger(KeyInput.KEY_6));
		tg.getInputManager().addMapping("Bl6", new KeyTrigger(KeyInput.KEY_7));
		tg.getInputManager().addMapping("Bl7", new KeyTrigger(KeyInput.KEY_8));
		tg.getInputManager().addMapping("Bl8", new KeyTrigger(KeyInput.KEY_9));
		tg.getInputManager().addMapping("Bl9", new KeyTrigger(KeyInput.KEY_0));
		tg.getInputManager().addListener(inputListener, "Break","Place","Explosion","Light","Bl0","Bl1","Bl2","Bl3","Bl4","Bl5","Bl6","Bl7","Bl8","Bl9");
	}
	
	//Instantiate chunks in box:
	//+-----+------+
	//+            +
	//+            +
	//+     +      +
	//+            +
	//+            +
	//+------------+
	//The distance from the center to the middle of each edge is instRange
	
	int instRange = 5;
	
	//Distance to remove chunks
	//Little larger than instRange to prevent chunk flickering (
	int remDist = (int)(1.4142135624*instRange)+2;
	
	//add chunksAddPF chunks per frame
	int chunksAddPF = 1;
	//remove chunksRemPF chunks per frame
	int chunksRemPF = 1;
	
	//self for reference in actionlisteners
	AppStateWorld self;
	
	//Method to add a light at a position - basically is a call to LightingManager, then updates
	//all lit chunks.
	public void addLight(Vector3f pos) {
		LightingManager.addLight(new Vector3f((int)pos.x,(int)pos.y,(int)pos.z));
		ArrayList<Vector2f> lupdates=LightingManager.updateLights(self);
		for(Vector2f v : lupdates) {
			redoChunk((int)v.x,(int)v.y);
		}
	}
	//TODO: not used?
	//Place blocks[placeBlockInd]
	int placeBlockInd=2;
	
	//Input listener for all actions
	ActionListener inputListener = new ActionListener() {
		
		@Override
		public void onAction(String name, boolean isPressed, float tpf) {
			if(!isPressed)return;
			//Add light
			if(name.equals("Light")) {
				addLight(tg.getCamera().getLocation());
			}
			//Deprecated, TODO:remove
			if(name.startsWith("Bl")) {
				placeBlockInd=Integer.parseInt(name.replace("Bl",""));
			}
			//Break a block
			//Do raytraceresult, if the chunk pair returned is not null do something
			if(name.equals("Break")) {
				RayTraceResult rtr = rayTrace(tg.getCamera().getLocation(), tg.getCamera().getDirection());
				ChunkPair cp = findChunk(rtr.hitCX,rtr.hitCZ);
				if(cp!=null) {
					cp.data.data[rtr.hitX][rtr.hitY][rtr.hitZ]=null;
					ArrayList<Vector2f> lupdates=LightingManager.updateLights(self);
					if(lupdates.contains(new Vector2f(rtr.hitCX,rtr.hitCZ)))lupdates.remove(new Vector2f(rtr.hitCX,rtr.hitCZ));
					redoChunk(rtr.hitCX,rtr.hitCZ);
					for(Vector2f v : lupdates) {
						redoChunk((int)v.x,(int)v.y);
					}
				}
			}
			//Do explosion in destroyDist radius
			if(name.equals("Explosion")) {
				ArrayList<Vector2f> chunksToUpdate = new ArrayList<Vector2f>();
				Vector3f camPos = tg.getCamera().getLocation();
				int destroyDist = 50;
				int range = (int)(1.732*destroyDist);
				for(int x=-range;x<=range;x++) {
					for(int y=-range;y<=range;y++) {
						for(int z=-range;z<=range;z++) {
							if(x*x+y*y+z*z<destroyDist*destroyDist) {
								int rx = (int)camPos.x+x;
								int ry = (int)camPos.y+y;
								int rz = (int)camPos.z+z;
								int hcx=roundPos(rx)/16;
								int hcz=roundPos(rz)/16;
								int hx=roundPos(rx)%16;
								int hy=roundPos(ry);
								int hz=roundPos(rz)%16;
								while(hx<0) {
									hx+=16;
									hcx--;
								}
								while(hz<0) {
									hz+=16;
									hcz--;
								}
								while(hx>15) {
									hx-=16;
									hcx++;
								}
								while(hz>15) {
									hz-=16;
									hcz++;
								}
								if(hy<0)continue;
								if(hy>255)continue;
								findChunk(hcx,hcz).data.data[hx][hy][hz]=null;
								Vector2f cpos = new Vector2f(hcx,hcz);
								if(!chunksToUpdate.contains(cpos)) {
									chunksToUpdate.add(cpos);
								}
							}
						}
					}
				}
				LightingManager.updateLights(self);
				for(Vector2f v : chunksToUpdate) {
					redoChunk((int)v.x, (int)v.y);
				}
			}
			//Place a block
			//Do raytraceresult, if the chunk pair returned is not null do something
			if(name.equals("Place")) {
				RayTraceResult rtr = rayTrace(tg.getCamera().getLocation(),tg.getCamera().getDirection());
				ChunkPair cp = findChunk(rtr.lCX,rtr.lCZ);
				if(cp!=null) {
//					cp.data.data[rtr.lX][rtr.lY][rtr.lZ]=tg.blocks.get(placeBlockInd);
					cp.data.data[rtr.lX][rtr.lY][rtr.lZ]=Blocks.STONE.getDefaultState();
					LightingManager.updateLights(self);
//					addLight(new Vector3f(rtr.lCX*16+rtr.lX,rtr.lY,rtr.lCZ*16+rtr.lZ));
					redoChunk(rtr.lCX,rtr.lCZ);
				}
			}
		}
	};
	
	//Redo chunk - remove, then add
	//This is to redo lighting
	//DOESN'T regenerate chunk
	public void redoChunk(int cx, int cz) {
		ChunkPair cp = findChunk(cx,cz);
		removeChunk(cp);
		addChunk(cx, cz, cp.data,findChunk(cx-1,cz).data, findChunk(cx+1,cz).data, findChunk(cx,cz-1).data, findChunk(cx,cz+1).data);
	}
	
	@Override
	public void update(float tpf) {
		//Get camera position
		Vector3f camPos = tg.getCamera().getLocation();
		int camChunkPosX = (int)(camPos.x/16f);
		int camChunkPosZ = (int)(camPos.z/16f);
		int num=0;
		
		//Add chunks
		for(int x=-instRange;x<=instRange;x++) {
			for(int z=-instRange;z<=instRange;z++) {
				if(num>chunksAddPF)continue;
				int rx = x+camChunkPosX;
				int rz = z+camChunkPosZ;
				ChunkPair p = findChunk(rx,rz);
				if(p==null) {
					addChunk(rx,rz);
					num++;
				}else {
					if(!p.inst) {
						addChunk(rx,rz);
						num++;
					}
				}
			}
		}
		num=0;
		//Remove chunks
		for(int i=0;i<chunkInstPosses.size();i++) {
			if(num>chunksRemPF)continue;
			Vector2f chunkPos = chunkInstPosses.get(i);
			if(new Vector2f(camChunkPosX,camChunkPosZ).distance(chunkPos)>remDist) {
				removeChunk(i);
				num++;
			}
		}
	}
	
	//Removes chunk pair
	public void removeChunk(ChunkPair cp) {
		removeChunk(chunkInstPosses.indexOf(new Vector2f(cp.x,cp.z)));
	}
	
	//Removes chunk by index
	public void removeChunk(int index) {
		if(index==-1)return;
		Vector2f pos = chunkInstPosses.get(index);
		if(!chunkProvider.canChunkRemove((int)pos.x,(int)pos.y)) {
			System.out.println("Chunk remove at " + (int)pos.x + ", " + (int)pos.y + " denied by chunk provider.");
		}
		chunkProvider.onChunkRemoveBefore((int)pos.x, (int)pos.y);
		findChunk((int)pos.x, (int)pos.y).inst = false;
		chunkInstPosses.remove(index);
		tg.getRootNode().detachChild(chunkInstNodes.get(index));
		chunkInstNodes.remove(index);
		numChunks--;
		chunkProvider.onChunkRemoveAfter((int)pos.x, (int)pos.y);
	}
	
	//Adds chunk by position
	//To generate mesh, it requires (cx-1,cz),(cx+1,cz),(cx,cz-1),(cx,cz+1) chunks
	//to be generated.  If they aren't generated, then they will be.
	//TODO: chunkProvider should know before and after a chunk is made
	public void addChunk(int cx, int cz) {
		Chunk xmi=findChunk(cx-1,cz).data;
		Chunk xpl=findChunk(cx+1,cz).data;
		Chunk zmi=findChunk(cx,cz-1).data;
		Chunk zpl=findChunk(cx,cz+1).data;
		//null parameter in the calls to makeChunk should be tg.blocks
		if(xmi==null) {
			xmi=chunkProvider.makeChunk(cx-1, cz, null);
			chunks.add(new ChunkPair(cx-1,cz,xmi,false));
		}
		if(xpl==null) {
			xpl=chunkProvider.makeChunk(cx+1, cz, null);
			chunks.add(new ChunkPair(cx+1,cz,xpl,false));
		}
		if(zmi==null) {
			zmi=chunkProvider.makeChunk(cx, cz-1, null);
			chunks.add(new ChunkPair(cx,cz-1,zmi,false));
		}
		if(zpl==null) {
			zpl=chunkProvider.makeChunk(cx, cz+1, null);
			chunks.add(new ChunkPair(cx,cz+1,zpl,false));
		}
		Chunk cur = findChunk(cx,cz).data;
		if(cur==null) {
			cur=chunkProvider.makeChunk(cx, cz, null);
			chunks.add(new ChunkPair(cx,cz,cur,true));
		}
		addChunk(cx,cz,cur,xmi,xpl,zmi,zpl);
	}
	
	//Add a given chunk
	public void addChunk(int cx, int cz, Chunk chunk,Chunk xmi,Chunk xpl,Chunk zmi,Chunk zpl) {
		if(!chunkProvider.canChunkAdd(cx, cz)) {
			System.out.println("Chunk add at " + cx + ", " + cz + " denied by chunk provider.");
			return;
		}
		//Start timing
		Utils.startTiming();
//		new Thread(new Runnable() {public void run() {
		chunkProvider.onChunkAddBefore(cx, cz);
		findChunk(cx,cz).inst=true;
		numChunks++;
		chunkInstPosses.add(new Vector2f(cx,cz));
		MeshData mdataOpaque = chunk.generateMesh(cx,cz,MatType.Opaque, new Vector3f(cx*16,0,cz*16), xmi, xpl, zmi, zpl,this);
		Geometry geoOpaque = new Geometry("Opaque",mdataOpaque.makeMesh());
		geoOpaque.setMaterial(tg.matOpaque);

		MeshData mdataTransp = chunk.generateMesh(cx,cz,MatType.Transparent, new Vector3f(cx*16,0,cz*16), xmi, xpl, zmi, zpl,this);
		Geometry geoTransp = new Geometry("Transp",mdataTransp.makeMesh());
		geoTransp.setMaterial(tg.matTransp);
		geoTransp.setQueueBucket(Bucket.Transparent);
		
		Node node = new Node();
		node.attachChild(geoOpaque);
		node.attachChild(geoTransp);
		node.setModelBound(new BoundingSphere(Float.POSITIVE_INFINITY,Vector3f.ZERO));
		chunkInstNodes.add(node);
		
		tg.getRootNode().attachChild(node);
		chunkProvider.onChunkAddAfter(cx, cz);
		//End and print results of timing
		System.out.println("Chunk add " + cx+","+cz+": "+Utils.endTime());
//		}}).start();
	}

}
