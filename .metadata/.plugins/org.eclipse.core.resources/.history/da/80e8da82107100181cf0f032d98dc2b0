package co.megadodo.mcclone.gen.mine1;

import java.util.ArrayList;

import com.jme3.math.Vector2f;

import co.megadodo.mcclone.Utils;
import co.megadodo.mcclone.block.BlockState;
import co.megadodo.mcclone.block.Chunk;
import co.megadodo.mcclone.gen.AbstractChunkProvider;

//Chunk provider
//with complex biome algorithms
public class ChunkProviderMine1 extends AbstractChunkProvider {
	
	@Override
	public void initialize() {
		
	}

	@Override
	public boolean canChunkAdd(int cx, int cz) {
		return true;
	}
	public AbstractBiomeHeight findBiome(int x,int z) {
		//TODO: interpolation every 8 blocks
		float oax = 1000;//offset a x
		float oaz = 1000;//offset a y
		float obx=0;
		float obz=0;
		float za = 0.25f; //zoom a
		float zb = 0.25f;
		float r = Utils.noisePerlin2(x*za+oax, z*za+oaz)*100;//rainfall
		float t = Utils.noisePerlin2(x*zb+obx, z*zb+obz)*100;//temperature
//		System.out.println((a*a+b*b));
		if(r*r+t*t>5100)return ocean;
//		if(b<37.5&&a<25)return desert;
//		if(r<75) {
//			if(t<50)
//		}
		if(r>55&&t<30) {
			return rainForest;
		}
		if(r<25) {
			if(t<37.5)return savanna;
			if(t<65)return desert;
		}
		if(r<50) {
			if(t<25)return savannaMountains;
			if(t<40)return birchForest;
		}
		if(r<75) {
			if(t<25)return birchOakForest;
			if(t<40)return oakForest;
		}
		if(r>25) {
			if(t<45)return taiga;
			if(t<60)return mountains;
		}
		
		//TODO:snowy tundra spawns too often?
		//TODO:mountains spawn too often?
		//TODO:leave as is?
		return tundra;
	}
	class TestBiome extends AbstractBiome{
		BlockState[] top;
		int height;
		public TestBiome(int h,BlockState... b) {
			top=b;
			height=h;
		}
		@Override
		public BlockState[] paintColumn(int x, int z) {
			BlockState[] bs=Utils.emptyColumn();
			bs[height]=top[(int)(Math.random()*top.length)];
			return bs;
		}
	}
	static AbstractBiomeHeight mountains=new AbstractBiomeHeight();
	static AbstractBiomeHeight taiga=new AbstractBiomeHeight();
	static AbstractBiomeHeight rainForest=new AbstractBiomeHeight();
	static AbstractBiomeHeight birchOakForest=new AbstractBiomeHeight();
	static AbstractBiomeHeight birchForest=new AbstractBiomeHeight();
	static AbstractBiomeHeight oakForest=new AbstractBiomeHeight();
	static AbstractBiomeHeight ocean=new AbstractBiomeHeight();
	static AbstractBiomeHeight desert=new AbstractBiomeHeight();
	static AbstractBiomeHeight savanna=new AbstractBiomeHeight();
	static AbstractBiomeHeight savannaMountains=new AbstractBiomeHeight();
	static AbstractBiomeHeight tundra=new AbstractBiomeHeight();
//	TestBiome mountains=new TestBiome(4,Blocks.STONE.getDefaultState());
//	TestBiome taiga=new TestBiome(3,Blocks.GRASS.getState("Mountain"));
//	TestBiome rainForest=new TestBiome(3,Blocks.LOG_JUNGLE.getDefaultState());
//	TestBiome birchOakForest=new TestBiome(2,Blocks.LOG_OAK.getDefaultState(),Blocks.LOG_BIRCH.getDefaultState());
//	TestBiome birchForest=new TestBiome(2,Blocks.LOG_BIRCH.getDefaultState());
//	TestBiome oakForest=new TestBiome(2,Blocks.LOG_OAK.getDefaultState());
//	TestBiome ocean=new TestBiome(1,Blocks.WATER.getDefaultState());
//	TestBiome desert=new TestBiome(2,Blocks.SAND.getDefaultState());
//	TestBiome savanna=new TestBiome(2,Blocks.GRASS.getState("Savanna"));
//	TestBiome savannaMountains=new TestBiome(3,Blocks.GRASS.getState("Savanna"));
//	TestBiome tundra=new TestBiome(2,Blocks.SNOW.getDefaultState());
	static class ExprNoise implements Expr<Integer>{
		
		float zoom,min,max;
		Vector2f offset;
		
		public ExprNoise(float z,float mi,float ma) {
			zoom=z;
			min=mi;
			max=ma;
			offset=new Vector2f(Utils.randFloat(1000),Utils.randFloat(1000));
		}

		@Override
		public Integer evaluate(int x, int y, int z) {
			return (int)(Utils.noisePerlin2(x*zoom+offset.x, z*zoom+offset.y)*(max-min)+min);
		}
		
	}
	static class ExprBlockRand implements Expr<BlockState>{
		BlockState[] bls;
		public ExprBlockRand(BlockState...blockStates) {
			bls=blockStates;
		}
		@Override
		public BlockState evaluate(int x,int y,int z) {
			return bls[(int)(Math.random()*bls.length)];
		}
	}
	static {
		mountains.top=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		mountains.mid=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		mountains.bot=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		mountains.height=new ExprNoise(3,100,130);
		
		taiga.top=new ExprLit<BlockState>(Blocks.GRASS.getState("Mountain"));
		taiga.mid=new ExprLit<BlockState>(Blocks.DIRT.getDefaultState());
		taiga.bot=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		taiga.height=new ExprNoise(6f,90,100);
		
		rainForest.top=new ExprLit<BlockState>(Blocks.LOG_JUNGLE.getDefaultState());
		rainForest.mid=new ExprLit<BlockState>(Blocks.DIRT.getDefaultState());
		rainForest.bot=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		rainForest.height=new ExprNoise(5,60,100);
		
		birchOakForest.top=new ExprBlockRand(Blocks.LOG_BIRCH.getDefaultState(),Blocks.LOG_OAK.getDefaultState());
		birchForest.top=new ExprLit<BlockState>(Blocks.GRASS.getState("Forest"));
		oakForest.top=new ExprLit<BlockState>(Blocks.GRASS.getState("Forest"));

		birchOakForest.mid=birchForest.mid=oakForest.mid=new ExprLit<BlockState>(Blocks.DIRT.getDefaultState());
		birchOakForest.bot=birchForest.bot=oakForest.bot=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		birchOakForest.height=birchForest.height=oakForest.height=new ExprNoise(4, 60, 80);

		ocean.top=new ExprLit<BlockState>(Blocks.WATER.getDefaultState());
		ocean.mid=new ExprLit<BlockState>(Blocks.WATER.getDefaultState());
		ocean.bot=new ExprLit<BlockState>(Blocks.WATER.getDefaultState());
		ocean.height=new ExprLit<Integer>(60);
		
		desert.top=new ExprLit<BlockState>(Blocks.SAND.getDefaultState());
		desert.mid=new ExprLit<BlockState>(Blocks.SAND.getDefaultState());
		desert.bot=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		desert.height=birchOakForest.height;
		
		savanna.top=savannaMountains.top=new ExprLit<BlockState>(Blocks.GRASS.getState("Savanna"));
		savanna.mid=savannaMountains.mid=new ExprLit<BlockState>(Blocks.DIRT.getDefaultState());
		savanna.bot=savannaMountains.bot=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		savanna.height=new ExprNoise(4, 60, 80);
		savannaMountains.height=new ExprNoise(2,150,250);
		
		tundra.top=new ExprLit<BlockState>(Blocks.SNOW.getDefaultState());
		tundra.mid=new ExprLit<BlockState>(Blocks.DIRT.getDefaultState());
		tundra.bot=new ExprLit<BlockState>(Blocks.STONE.getDefaultState());
		tundra.height=new ExprNoise(4, 60, 80);
	}
	int[][] getHeights(int cx,int cz){
		int[][] heights=new int[5][5];
		int[][]actuals=new int[16][16];
		for(int x=0;x<5;x++) {
			for(int z=0;z<5;z++) {
//				heights[x][z]=height(cx*16+8*x,cz*16+8*z);
				int rx=cx*16+4*x,rz=cz*16+4*z;
				AbstractBiomeHeight b=findBiome(rx,rz);
				int xoff=(int)(Utils.noisePerlin2(rx*0.1f,rz*0.1f)*10-5);
				int zoff=(int)(Utils.noisePerlin2(rx*0.1f+100,rz*0.1f)*10-5);
				if(b==null)heights[x][z]=255;
				else heights[x][z]=b.height.evaluate(cx*16+4*x+xoff, -1, cz*16+4*z+zoff);
			}
		}
		for(int x=0;x<16;x++) {
			for(int z=0;z<16;z++) {
				int sx=x/4;
				int sz=z/4;
				int a00=heights[sx][sz];
				int a10=heights[sx+1][sz];
				int a01=heights[sx][sz+1];
				int a11=heights[sx+1][sz+1];
				float xinsec=(x%4)/4f;
				float zinsec=(z%4)/4f;
//				int height=(int)Utils.blerp(a00,a10,a01,a11,xinsec,zinsec);
//				int height=Math.round(Utils.blerp(a00, a10,a01,a11,xinsec,zinsec));
//				float heightF=a00+a10*xinsec;
				actuals[x][z]=(int)Utils.blerp(a00, a10, a01, a11, xinsec, zinsec);
			}
		}
		return actuals;
	}
	
	@Override
	public Chunk makeChunk(int cx, int cz, ArrayList<BlockState> bls) {
		Utils.startTiming();
		ensureDeco(cx-1,cz);
		ensureDeco(cx+1,cz);
		ensureDeco(cx,cz-1);
		ensureDeco(cx,cz+1);
		ensureDeco(cx,cz);
		Chunk chunk = new Chunk();
		int[][]heights=getHeights(cx,cz);
		for(int x=0;x<16;x++) {
			for(int z=0;z<16;z++) {
				AbstractBiomeHeight b=findBiome(cx*16+x,cz*16+z);
				if(b==null)continue;

//				int height=(int)Utils.blerp(a00,a10,a01,a11,xinsec,zinsec);
//				int height=Math.round(Utils.blerp(a00, a10,a01,a11,xinsec,zinsec));
//				float heightF=a00+a10*xinsec;
				int height=heights[x][z];
//				chunk.data[x][height][z]=b.top[(int)(Math.random()*b.top.length)];
//				chunk.setColumn(x, z, b.paintColumn(x+cx*16,	 z+cz*16));
				for(int y=0;y<height-10;y++) {
					chunk.data[x][y][z]=b.bot.evaluate(cx*16+x, y, cz*16+z);
				}
				for(int y=height-10;y<height;y++) {
					chunk.data[x][y][z]=b.mid.evaluate(cx*16+x, y, cz*16+z);
				}
				chunk.data[x][height][z]=b.top.evaluate(cx*16+x, height, cz*16+z);
//				pairs.addAll(b.spawnDecos(x+cx*16,b.height.evaluate(x+cx*16, -1, z+cz*16),z+cz*16));
//				chunk.data[x][(int)(Utils.noisePerlin2(x+cx*16, z+cz*16)*20)][z]=Blocks.GRASS.getDefaultState();
			}
		}
//		for(int i=0;i<pairs.size();i++) {
//			BlockPair p=pairs.get(i);
//			if(p.cx==cx&&p.cz==cz) {
//				chunk.data[p.rx][p.ry][p.rz]=p.bl;
//				pairs.remove(p);
//			}
//		}
//		ArrayList<BlockPair> toRemove=new ArrayList<BlockPair>();
//		for(BlockPair p : pairs) {
//			if(p.cx==cx&&p.cz==cz) {
//				chunk.data[p.rx][p.ry][p.rz]=p.bl;
//				toRemove.add(p);
//			}
//		}
		boolean doneDeco=false;
		for(int i=0;i<decoChunks.size();i++) {
			if(doneDeco)continue;
			if(decoChunks.get(i).equals(new Vector2f(cx,cz))) {
				doneDeco=true;
				ArrayList<BlockPair> ps=pairs.get(i);
				for(BlockPair p:ps) {
					chunk.data[p.x][p.y][p.z]=p.bl;
				}
				decoChunks.remove(i);
				pairs.remove(i);
			}
		}
		System.out.println("Time for chunk " + cx + ","+cz+": " + Utils.endTime());
		return chunk;
	}
	static ArrayList<Vector2f>decoChunks=new ArrayList<Vector2f>();
	static ArrayList<ArrayList<BlockPair>>pairs=new ArrayList<ArrayList<BlockPair>>();
	
	class BlockPair{
		int cx,cz,x,y,z;
		BlockState bl;
		BlockPair(int rx,int ry,int rz,BlockState bl){
			this(0,0,rx,ry,rz,bl);
		}
		BlockPair(int _cx,int _cz,int rx,int ry,int rz,BlockState bl){
			x=rx;
			y=ry;
			z=rz;
			this.cx=_cx;
			this.cz=_cz;
			this.bl=bl;
			updatePosses();
		}
		BlockPair updatePosses() {
			while(x<0) {
				x+=16;
				cx--;
			}
			while(z<0) {
				z+=16;
				cz--;
			}
			while(x>15) {
				x-=16;
				cx++;
			}
			while(z>15) {
				z-=16;
				cz++;
			}
			return this;
		}
	}

	@Override
	public void onChunkRemoveBefore(int cx, int cz) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void onChunkRemoveAfter(int cx, int cz) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean canChunkRemove(int cx, int cz) {
		return true;
	}

	@Override
	public void onChunkAddBefore(int cx, int cz) {
//		for(int x=0;x<16;x++) {
//			for(int z=0;z<16;z++) {
//				pairs.addAll(new BiomeTest().spawnDecos(cx*16+x, new BiomeTest().height.evaluate(cx*16+x, -1, cz*16+z)+1, cz*16+z));
//			}
//		}
	}
	
	public void ensureDeco(int cx,int cz) {
		if(!decoChunks.contains(new Vector2f(cx,cz))) {
			decoChunks.add(new Vector2f(cx,cz));
			pairs.add(deco(cx,cz));
		}
	}
	
	public ArrayList<BlockPair> deco(int cx,int cz) {
		int[][]heights=getHeights(cx,cz);
		ArrayList<BlockPair> ps=new ArrayList<BlockPair>();
		for(int x=0;x<16;x++) {
			for(int z=0;z<16;z++) {
				AbstractBiomeHeight biome=findBiome(x+cx*16,z+cz*16);
				BlockState log=null;
				BlockState leaf=null;
				if(biome.equals(oakForest)) {
					log=Blocks.LOG_OAK.getDefaultState();
					leaf=Blocks.LEAVES_OAK.getDefaultState();
				}
				if(biome.equals(birchForest)) {
					log=Blocks.LOG_BIRCH.getDefaultState();
					leaf=Blocks.LEAVES_BIRCH.getDefaultState();
				}
				if(log==null)continue;
				int treeHeight=(int)Utils.randFloat(3,5);
				int lsize=(int)Utils.randFloat(2);
				if(Utils.randFloat()<0.01) {
					for(int y=1;y<=treeHeight;y++) {
						ps.add(new BlockPair(cx, cz, x, heights[x][z]+y,z,log));
					}
					for(int lx=-lsize;lx<=lsize;lx++) {
						for(int ly=-lsize;ly<=lsize;ly++) {
							for(int lz=-lsize;lz<=lsize;lz++) {
								ps.add(new BlockPair(cx*16+x+lx,heights[x][z]+treeHeight+ly,cz*16+z+lz,leaf));
							}
						}
					}
				}
			}
		}
		return ps;
	}

	@Override
	public void onChunkAddAfter(int cx, int cz) {
		// TODO Auto-generated method stub
		
	}

}
