package co.megadodo.shaderfun;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;

import javax.media.opengl.GL3;

public class VertexBuffer {

	public VertexBuffer() {

	}

	public int vao;
	public int vbo;
	public int ebo;

	public void genBuffers(GL3 gl, FloatBuffer posData, IntBuffer triData) {
		IntBuffer vaoBuffer = IntBuffer.wrap(new int[] { vao });
		gl.glGenVertexArrays(1, vaoBuffer);
		vao = vaoBuffer.get(0);

		IntBuffer vboBuffer = IntBuffer.allocate(1);
		gl.glGenBuffers(2, vboBuffer);
		vbo=vboBuffer.get(0);
		
		IntBuffer eboBuffer=IntBuffer.allocate(1);
		gl.glGenBuffers(1, eboBuffer);
		ebo=eboBuffer.get(0);

		gl.glBindVertexArray(vao);
	    
		gl.glBindBuffer(GL3.GL_ARRAY_BUFFER, vbo);
		gl.glBufferData(GL3.GL_ARRAY_BUFFER, vertsSize, verts, GL3.GL_STATIC_DRAW);
		
		gl.glBindBuffer(GL3.GL_ELEMENT_ARRAY_BUFFER, ebo);
		gl.glBufferData(GL3.GL_ELEMENT_ARRAY_BUFFER, triData.capacity(), triData, GL3.GL_STATIC_DRAW);
		
		gl.glVertexAttribPointer(0, 3, GL3.GL_FLOAT, GL3.GL_FALSE, 3 * sizeof(float), (void*)0);
		gl.glEnableVertexAttribArray(0);
		
		// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind
		gl.glBindBuffer(GL3.GL_ARRAY_BUFFER, 0);
	    
		// remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
		//	    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
	    
		// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other
		// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.
		gl.glBindVertexArray(0);
	}

	public void bindBuffers(GL3 gl) {
		gl.glBindVertexArray(vao);
		gl.glDrawArrays(GL3.GL_TRIANGLES, 0, 3);
		gl.glBindVertexArray(0);
	}

	public void deleteBuffers(GL3 gl) {
	}

}
